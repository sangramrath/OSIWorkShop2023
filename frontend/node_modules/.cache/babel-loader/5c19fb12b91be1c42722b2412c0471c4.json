{"ast":null,"code":"var _slicedToArray = require(\"/Users/sangram/Documents/OSI/testlab/squidex-samples/jscript/react/sample-hotels/node_modules/@babel/runtime/helpers/slicedToArray\");\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.graphqlWs = {}));\n})(this, function (exports) {\n  'use strict';\n  /** @private */\n\n  function extendedTypeof(val) {\n    if (val === null) {\n      return 'null';\n    }\n\n    if (Array.isArray(val)) {\n      return 'array';\n    }\n\n    return typeof val;\n  }\n  /** @private */\n\n\n  function isObject(val) {\n    return extendedTypeof(val) === 'object';\n  }\n  /** @private */\n\n\n  function areGraphQLErrors(obj) {\n    return Array.isArray(obj) && // must be at least one error\n    obj.length > 0 && // error has at least a message\n    obj.every(ob => 'message' in ob);\n  }\n  /**\n   * Limits the WebSocket close event reason to not exceed a length of one frame.\n   * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n   *\n   * @private\n   */\n\n\n  function limitCloseReason(reason, whenTooLong) {\n    return reason.length < 124 ? reason : whenTooLong;\n  }\n  /**\n   *\n   * common\n   *\n   */\n\n  /**\n   * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n   *\n   * @category Common\n   */\n\n\n  const GRAPHQL_TRANSPORT_WS_PROTOCOL = 'graphql-transport-ws';\n  /**\n   * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n   *\n   * @private\n   */\n\n  const DEPRECATED_GRAPHQL_WS_PROTOCOL = 'graphql-ws';\n  /**\n   * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n   *\n   * @category Common\n   */\n\n  exports.CloseCode = void 0;\n\n  (function (CloseCode) {\n    CloseCode[CloseCode[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n    CloseCode[CloseCode[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n    CloseCode[CloseCode[\"BadRequest\"] = 4400] = \"BadRequest\";\n    CloseCode[CloseCode[\"BadResponse\"] = 4004] = \"BadResponse\";\n    /** Tried subscribing before connect ack */\n\n    CloseCode[CloseCode[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n    CloseCode[CloseCode[\"Forbidden\"] = 4403] = \"Forbidden\";\n    CloseCode[CloseCode[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n    CloseCode[CloseCode[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n    CloseCode[CloseCode[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n    /** Subscriber distinction is very important */\n\n    CloseCode[CloseCode[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n    CloseCode[CloseCode[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n  })(exports.CloseCode || (exports.CloseCode = {}));\n  /**\n   * Types of messages allowed to be sent by the client/server over the WS protocol.\n   *\n   * @category Common\n   */\n\n\n  exports.MessageType = void 0;\n\n  (function (MessageType) {\n    MessageType[\"ConnectionInit\"] = \"connection_init\";\n    MessageType[\"ConnectionAck\"] = \"connection_ack\";\n    MessageType[\"Ping\"] = \"ping\";\n    MessageType[\"Pong\"] = \"pong\";\n    MessageType[\"Subscribe\"] = \"subscribe\";\n    MessageType[\"Next\"] = \"next\";\n    MessageType[\"Error\"] = \"error\";\n    MessageType[\"Complete\"] = \"complete\";\n  })(exports.MessageType || (exports.MessageType = {}));\n  /**\n   * Validates the message against the GraphQL over WebSocket Protocol.\n   *\n   * Invalid messages will throw descriptive errors.\n   *\n   * @category Common\n   */\n\n\n  function validateMessage(val) {\n    if (!isObject(val)) {\n      throw new Error(`Message is expected to be an object, but got ${extendedTypeof(val)}`);\n    }\n\n    if (!val.type) {\n      throw new Error(`Message is missing the 'type' property`);\n    }\n\n    if (typeof val.type !== 'string') {\n      throw new Error(`Message is expects the 'type' property to be a string, but got ${extendedTypeof(val.type)}`);\n    }\n\n    switch (val.type) {\n      case exports.MessageType.ConnectionInit:\n      case exports.MessageType.ConnectionAck:\n      case exports.MessageType.Ping:\n      case exports.MessageType.Pong:\n        {\n          if ('payload' in val && !isObject(val.payload)) {\n            throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object or missing, but got \"${val.payload}\"`);\n          }\n\n          break;\n        }\n\n      case exports.MessageType.Subscribe:\n        {\n          if (typeof val.id !== 'string') {\n            throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n          }\n\n          if (!val.id) {\n            throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n          }\n\n          if (!isObject(val.payload)) {\n            throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${extendedTypeof(val.payload)}`);\n          }\n\n          if (typeof val.payload.query !== 'string') {\n            throw new Error(`\"${val.type}\" message payload expects the 'query' property to be a string, but got ${extendedTypeof(val.payload.query)}`);\n          }\n\n          if (val.payload.variables != null && !isObject(val.payload.variables)) {\n            throw new Error(`\"${val.type}\" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${extendedTypeof(val.payload.variables)}`);\n          }\n\n          if (val.payload.operationName != null && extendedTypeof(val.payload.operationName) !== 'string') {\n            throw new Error(`\"${val.type}\" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${extendedTypeof(val.payload.operationName)}`);\n          }\n\n          if (val.payload.extensions != null && !isObject(val.payload.extensions)) {\n            throw new Error(`\"${val.type}\" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${extendedTypeof(val.payload.extensions)}`);\n          }\n\n          break;\n        }\n\n      case exports.MessageType.Next:\n        {\n          if (typeof val.id !== 'string') {\n            throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n          }\n\n          if (!val.id) {\n            throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n          }\n\n          if (!isObject(val.payload)) {\n            throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${extendedTypeof(val.payload)}`);\n          }\n\n          break;\n        }\n\n      case exports.MessageType.Error:\n        {\n          if (typeof val.id !== 'string') {\n            throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n          }\n\n          if (!val.id) {\n            throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n          }\n\n          if (!areGraphQLErrors(val.payload)) {\n            throw new Error(`\"${val.type}\" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(val.payload)}`);\n          }\n\n          break;\n        }\n\n      case exports.MessageType.Complete:\n        {\n          if (typeof val.id !== 'string') {\n            throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n          }\n\n          if (!val.id) {\n            throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n          }\n\n          break;\n        }\n\n      default:\n        throw new Error(`Invalid message 'type' property \"${val.type}\"`);\n    }\n\n    return val;\n  }\n  /**\n   * Checks if the provided value is a valid GraphQL over WebSocket message.\n   *\n   * @deprecated Use `validateMessage` instead.\n   *\n   * @category Common\n   */\n\n\n  function isMessage(val) {\n    try {\n      validateMessage(val);\n      return true;\n    } catch (_a) {\n      return false;\n    }\n  }\n  /**\n   * Parses the raw websocket message data to a valid message.\n   *\n   * @category Common\n   */\n\n\n  function parseMessage(data, reviver) {\n    try {\n      return validateMessage(data);\n    } catch (_a) {\n      if (typeof data !== 'string') {\n        throw new Error('Only strings are parsable messages');\n      }\n\n      const message = JSON.parse(data, reviver);\n      return validateMessage(message);\n    }\n  }\n  /**\n   * Stringifies a valid message ready to be sent through the socket.\n   *\n   * @category Common\n   */\n\n\n  function stringifyMessage(msg, replacer) {\n    validateMessage(msg);\n    return JSON.stringify(msg, replacer);\n  }\n  /**\n   *\n   * client\n   *\n   */\n\n  /**\n   * Creates a disposable GraphQL over WebSocket client.\n   *\n   * @category Client\n   */\n\n\n  function createClient(options) {\n    const url = options.url,\n          connectionParams = options.connectionParams,\n          _options$lazy = options.lazy,\n          lazy = _options$lazy === void 0 ? true : _options$lazy,\n          _options$onNonLazyErr = options.onNonLazyError,\n          onNonLazyError = _options$onNonLazyErr === void 0 ? console.error : _options$onNonLazyErr,\n          _options$lazyCloseTim = options.lazyCloseTimeout,\n          lazyCloseTimeoutMs = _options$lazyCloseTim === void 0 ? 0 : _options$lazyCloseTim,\n          _options$keepAlive = options.keepAlive,\n          keepAlive = _options$keepAlive === void 0 ? 0 : _options$keepAlive,\n          disablePong = options.disablePong,\n          _options$connectionAc = options.connectionAckWaitTimeout,\n          connectionAckWaitTimeout = _options$connectionAc === void 0 ? 0 : _options$connectionAc,\n          _options$retryAttempt = options.retryAttempts,\n          retryAttempts = _options$retryAttempt === void 0 ? 5 : _options$retryAttempt,\n          _options$retryWait = options.retryWait,\n          retryWait = _options$retryWait === void 0 ? async function randomisedExponentialBackoff(retries) {\n      let retryDelay = 1000; // start with 1s delay\n\n      for (let i = 0; i < retries; i++) {\n        retryDelay *= 2;\n      }\n\n      await new Promise(resolve => setTimeout(resolve, retryDelay + // add random timeout from 300ms to 3s\n      Math.floor(Math.random() * (3000 - 300) + 300)));\n    } : _options$retryWait,\n          _options$shouldRetry = options.shouldRetry,\n          shouldRetry = _options$shouldRetry === void 0 ? isLikeCloseEvent : _options$shouldRetry,\n          isFatalConnectionProblem = options.isFatalConnectionProblem,\n          on = options.on,\n          webSocketImpl = options.webSocketImpl,\n          _options$generateID = options.generateID,\n          generateID = _options$generateID === void 0 ? function generateUUID() {\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = Math.random() * 16 | 0,\n              v = c == 'x' ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n      });\n    } : _options$generateID,\n          replacer = options.jsonMessageReplacer,\n          reviver = options.jsonMessageReviver;\n    let ws;\n\n    if (webSocketImpl) {\n      if (!isWebSocket(webSocketImpl)) {\n        throw new Error('Invalid WebSocket implementation provided');\n      }\n\n      ws = webSocketImpl;\n    } else if (typeof WebSocket !== 'undefined') {\n      ws = WebSocket;\n    } else if (typeof global !== 'undefined') {\n      ws = global.WebSocket || // @ts-expect-error: Support more browsers\n      global.MozWebSocket;\n    } else if (typeof window !== 'undefined') {\n      ws = window.WebSocket || // @ts-expect-error: Support more browsers\n      window.MozWebSocket;\n    }\n\n    if (!ws) throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws; // websocket status emitter, subscriptions are handled differently\n\n    const emitter = (() => {\n      const message = (() => {\n        const listeners = {};\n        return {\n          on(id, listener) {\n            listeners[id] = listener;\n            return () => {\n              delete listeners[id];\n            };\n          },\n\n          emit(message) {\n            var _a;\n\n            if ('id' in message) (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n          }\n\n        };\n      })();\n\n      const listeners = {\n        connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n        opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n        connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n        ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n        pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n        message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n        closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n        error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : []\n      };\n      return {\n        onMessage: message.on,\n\n        on(event, listener) {\n          const l = listeners[event];\n          l.push(listener);\n          return () => {\n            l.splice(l.indexOf(listener), 1);\n          };\n        },\n\n        emit(event, ...args) {\n          // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n          for (const listener of [...listeners[event]]) {\n            // @ts-expect-error: The args should fit\n            listener(...args);\n          }\n        }\n\n      };\n    })(); // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n\n\n    function errorOrClosed(cb) {\n      const listening = [// errors are fatal and more critical than close events, throw them first\n      emitter.on('error', err => {\n        listening.forEach(unlisten => unlisten());\n        cb(err);\n      }), // closes can be graceful and not fatal, throw them second (if error didnt throw)\n      emitter.on('closed', event => {\n        listening.forEach(unlisten => unlisten());\n        cb(event);\n      })];\n    }\n\n    let connecting,\n        locks = 0,\n        lazyCloseTimeout,\n        retrying = false,\n        retries = 0,\n        disposed = false;\n\n    async function connect() {\n      // clear the lazy close timeout immediatelly so that close gets debounced\n      // see: https://github.com/enisdenjo/graphql-ws/issues/388\n      clearTimeout(lazyCloseTimeout);\n\n      const _ref = await (connecting !== null && connecting !== void 0 ? connecting : connecting = new Promise((connected, denied) => (async () => {\n        if (retrying) {\n          await retryWait(retries); // subscriptions might complete while waiting for retry\n\n          if (!locks) {\n            connecting = undefined;\n            return denied({\n              code: 1000,\n              reason: 'All Subscriptions Gone'\n            });\n          }\n\n          retries++;\n        }\n\n        emitter.emit('connecting');\n        const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n        let connectionAckTimeout, queuedPing;\n\n        function enqueuePing() {\n          if (isFinite(keepAlive) && keepAlive > 0) {\n            clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n\n            queuedPing = setTimeout(() => {\n              if (socket.readyState === WebSocketImpl.OPEN) {\n                socket.send(stringifyMessage({\n                  type: exports.MessageType.Ping\n                }));\n                emitter.emit('ping', false, undefined);\n              }\n            }, keepAlive);\n          }\n        }\n\n        errorOrClosed(errOrEvent => {\n          connecting = undefined;\n          clearTimeout(connectionAckTimeout);\n          clearTimeout(queuedPing);\n          denied(errOrEvent);\n\n          if (isLikeCloseEvent(errOrEvent) && errOrEvent.code === 4499) {\n            socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n\n            socket.onerror = null;\n            socket.onclose = null;\n          }\n        });\n\n        socket.onerror = err => emitter.emit('error', err);\n\n        socket.onclose = event => emitter.emit('closed', event);\n\n        socket.onopen = async () => {\n          try {\n            emitter.emit('opened', socket);\n            const payload = typeof connectionParams === 'function' ? await connectionParams() : connectionParams; // connectionParams might take too long causing the server to kick off the client\n            // the necessary error/close event is already reported - simply stop execution\n\n            if (socket.readyState !== WebSocketImpl.OPEN) return;\n            socket.send(stringifyMessage(payload ? {\n              type: exports.MessageType.ConnectionInit,\n              payload\n            } : {\n              type: exports.MessageType.ConnectionInit // payload is completely absent if not provided\n\n            }, replacer));\n\n            if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {\n              connectionAckTimeout = setTimeout(() => {\n                socket.close(exports.CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n              }, connectionAckWaitTimeout);\n            }\n\n            enqueuePing(); // enqueue ping (noop if disabled)\n          } catch (err) {\n            emitter.emit('error', err);\n            socket.close(exports.CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n          }\n        };\n\n        let acknowledged = false;\n\n        socket.onmessage = ({\n          data\n        }) => {\n          try {\n            const message = parseMessage(data, reviver);\n            emitter.emit('message', message);\n\n            if (message.type === 'ping' || message.type === 'pong') {\n              emitter.emit(message.type, true, message.payload); // received\n\n              if (message.type === 'pong') {\n                enqueuePing(); // enqueue next ping (noop if disabled)\n              } else if (!disablePong) {\n                // respond with pong on ping\n                socket.send(stringifyMessage(message.payload ? {\n                  type: exports.MessageType.Pong,\n                  payload: message.payload\n                } : {\n                  type: exports.MessageType.Pong // payload is completely absent if not provided\n\n                }));\n                emitter.emit('pong', false, message.payload);\n              }\n\n              return; // ping and pongs can be received whenever\n            }\n\n            if (acknowledged) return; // already connected and acknowledged\n\n            if (message.type !== exports.MessageType.ConnectionAck) throw new Error(`First message cannot be of type ${message.type}`);\n            clearTimeout(connectionAckTimeout);\n            acknowledged = true;\n            emitter.emit('connected', socket, message.payload); // connected = socket opened + acknowledged\n\n            retrying = false; // future lazy connects are not retries\n\n            retries = 0; // reset the retries on connect\n\n            connected([socket, new Promise((_, reject) => errorOrClosed(reject))]);\n          } catch (err) {\n            socket.onmessage = null; // stop reading messages as soon as reading breaks once\n\n            emitter.emit('error', err);\n            socket.close(exports.CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n          }\n        };\n      })())),\n            _ref2 = _slicedToArray(_ref, 2),\n            socket = _ref2[0],\n            throwOnClose = _ref2[1]; // if the provided socket is in a closing state, wait for the throw on close\n\n\n      if (socket.readyState === WebSocketImpl.CLOSING) await throwOnClose;\n\n      let release = () => {// releases this connection\n      };\n\n      const released = new Promise(resolve => release = resolve);\n      return [socket, release, Promise.race([// wait for\n      released.then(() => {\n        if (!locks) {\n          // and if no more locks are present, complete the connection\n          const complete = () => socket.close(1000, 'Normal Closure');\n\n          if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n            // if the keepalive is set, allow for the specified calmdown time and\n            // then complete if the socket is still open.\n            lazyCloseTimeout = setTimeout(() => {\n              if (socket.readyState === WebSocketImpl.OPEN) complete();\n            }, lazyCloseTimeoutMs);\n          } else {\n            // otherwise complete immediately\n            complete();\n          }\n        }\n      }), // or\n      throwOnClose])];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */\n\n\n    function shouldRetryConnectOrThrow(errOrCloseEvent) {\n      // some close codes are worth reporting immediately\n      if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [exports.CloseCode.InternalServerError, exports.CloseCode.InternalClientError, exports.CloseCode.BadRequest, exports.CloseCode.BadResponse, exports.CloseCode.Unauthorized, // CloseCode.Forbidden, might grant access out after retry\n      exports.CloseCode.SubprotocolNotAcceptable, // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n      // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n      exports.CloseCode.SubscriberAlreadyExists, exports.CloseCode.TooManyInitialisationRequests // 4499, // Terminated, probably because the socket froze, we want to retry\n      ].includes(errOrCloseEvent.code))) throw errOrCloseEvent; // client was disposed, no retries should proceed regardless\n\n      if (disposed) return false; // normal closure (possibly all subscriptions have completed)\n      // if no locks were acquired in the meantime, shouldnt try again\n\n      if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000) return locks > 0; // retries are not allowed or we tried to many times, report error\n\n      if (!retryAttempts || retries >= retryAttempts) throw errOrCloseEvent; // throw non-retryable connection problems\n\n      if (!shouldRetry(errOrCloseEvent)) throw errOrCloseEvent; // @deprecated throw fatal connection problems immediately\n\n      if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent)) throw errOrCloseEvent; // looks good, start retrying\n\n      return retrying = true;\n    } // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n\n\n    if (!lazy) {\n      (async () => {\n        locks++;\n\n        for (;;) {\n          try {\n            const _ref3 = await connect(),\n                  _ref4 = _slicedToArray(_ref3, 3),\n                  throwOnClose = _ref4[2];\n\n            await throwOnClose; // will always throw because releaser is not used\n          } catch (errOrCloseEvent) {\n            try {\n              if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n            } catch (errOrCloseEvent) {\n              // report thrown error, no further retries\n              return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n            }\n          }\n        }\n      })();\n    }\n\n    return {\n      on: emitter.on,\n\n      subscribe(payload, sink) {\n        const id = generateID();\n\n        let done = false,\n            errored = false,\n            releaser = () => {\n          // for handling completions before connect\n          locks--;\n          done = true;\n        };\n\n        (async () => {\n          locks++;\n\n          for (;;) {\n            try {\n              const _ref5 = await connect(),\n                    _ref6 = _slicedToArray(_ref5, 3),\n                    socket = _ref6[0],\n                    release = _ref6[1],\n                    waitForReleaseOrThrowOnClose = _ref6[2]; // if done while waiting for connect, release the connection lock right away\n\n\n              if (done) return release();\n              const unlisten = emitter.onMessage(id, message => {\n                switch (message.type) {\n                  case exports.MessageType.Next:\n                    {\n                      sink.next(message.payload);\n                      return;\n                    }\n\n                  case exports.MessageType.Error:\n                    {\n                      errored = true, done = true;\n                      sink.error(message.payload);\n                      releaser();\n                      return;\n                    }\n\n                  case exports.MessageType.Complete:\n                    {\n                      done = true;\n                      releaser(); // release completes the sink\n\n                      return;\n                    }\n                }\n              });\n              socket.send(stringifyMessage({\n                id,\n                type: exports.MessageType.Subscribe,\n                payload\n              }, replacer));\n\n              releaser = () => {\n                if (!done && socket.readyState === WebSocketImpl.OPEN) // if not completed already and socket is open, send complete message to server on release\n                  socket.send(stringifyMessage({\n                    id,\n                    type: exports.MessageType.Complete\n                  }, replacer));\n                locks--;\n                done = true;\n                release();\n              }; // either the releaser will be called, connection completed and\n              // the promise resolved or the socket closed and the promise rejected.\n              // whatever happens though, we want to stop listening for messages\n\n\n              await waitForReleaseOrThrowOnClose.finally(unlisten);\n              return; // completed, shouldnt try again\n            } catch (errOrCloseEvent) {\n              if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n            }\n          }\n        })().then(() => {\n          // delivering either an error or a complete terminates the sequence\n          if (!errored) sink.complete();\n        }) // resolves on release or normal closure\n        .catch(err => {\n          sink.error(err);\n        }); // rejects on close events and errors\n\n        return () => {\n          // dispose only of active subscriptions\n          if (!done) releaser();\n        };\n      },\n\n      async dispose() {\n        disposed = true;\n\n        if (connecting) {\n          // if there is a connection, close it\n          const _ref7 = await connecting,\n                _ref8 = _slicedToArray(_ref7, 1),\n                socket = _ref8[0];\n\n          socket.close(1000, 'Normal Closure');\n        }\n      },\n\n      terminate() {\n        if (connecting) {\n          // only if there is a connection\n          emitter.emit('closed', {\n            code: 4499,\n            reason: 'Terminated',\n            wasClean: false\n          });\n        }\n      }\n\n    };\n  }\n\n  function isLikeCloseEvent(val) {\n    return isObject(val) && 'code' in val && 'reason' in val;\n  }\n\n  function isFatalInternalCloseCode(code) {\n    if ([1000, 1001, 1006, 1005, 1012, 1013, 1013 // Bad Gateway\n    ].includes(code)) return false; // all other internal errors are fatal\n\n    return code >= 1000 && code <= 1999;\n  }\n\n  function isWebSocket(val) {\n    return typeof val === 'function' && 'constructor' in val && 'CLOSED' in val && 'CLOSING' in val && 'CONNECTING' in val && 'OPEN' in val;\n  }\n\n  exports.DEPRECATED_GRAPHQL_WS_PROTOCOL = DEPRECATED_GRAPHQL_WS_PROTOCOL;\n  exports.GRAPHQL_TRANSPORT_WS_PROTOCOL = GRAPHQL_TRANSPORT_WS_PROTOCOL;\n  exports.createClient = createClient;\n  exports.isMessage = isMessage;\n  exports.parseMessage = parseMessage;\n  exports.stringifyMessage = stringifyMessage;\n  exports.validateMessage = validateMessage;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["/Users/sangram/Documents/OSI/testlab/squidex-samples/jscript/react/sample-hotels/node_modules/graphql-ws/umd/graphql-ws.js"],"names":["global","factory","exports","module","define","amd","globalThis","self","graphqlWs","extendedTypeof","val","Array","isArray","isObject","areGraphQLErrors","obj","length","every","ob","limitCloseReason","reason","whenTooLong","GRAPHQL_TRANSPORT_WS_PROTOCOL","DEPRECATED_GRAPHQL_WS_PROTOCOL","CloseCode","MessageType","validateMessage","Error","type","ConnectionInit","ConnectionAck","Ping","Pong","payload","Subscribe","id","query","variables","operationName","extensions","Next","JSON","stringify","Complete","isMessage","_a","parseMessage","data","reviver","message","parse","stringifyMessage","msg","replacer","createClient","options","url","connectionParams","lazy","onNonLazyError","console","error","lazyCloseTimeout","lazyCloseTimeoutMs","keepAlive","disablePong","connectionAckWaitTimeout","retryAttempts","retryWait","randomisedExponentialBackoff","retries","retryDelay","i","Promise","resolve","setTimeout","Math","floor","random","shouldRetry","isLikeCloseEvent","isFatalConnectionProblem","on","webSocketImpl","generateID","generateUUID","replace","c","r","v","toString","jsonMessageReplacer","jsonMessageReviver","ws","isWebSocket","WebSocket","MozWebSocket","window","WebSocketImpl","emitter","listeners","listener","emit","call","connecting","opened","connected","ping","pong","closed","onMessage","event","l","push","splice","indexOf","args","errorOrClosed","cb","listening","err","forEach","unlisten","locks","retrying","disposed","connect","clearTimeout","denied","undefined","code","socket","connectionAckTimeout","queuedPing","enqueuePing","isFinite","readyState","OPEN","send","errOrEvent","close","onerror","onclose","onopen","ConnectionAcknowledgementTimeout","InternalClientError","acknowledged","onmessage","_","reject","BadResponse","throwOnClose","CLOSING","release","released","race","then","complete","shouldRetryConnectOrThrow","errOrCloseEvent","isFatalInternalCloseCode","InternalServerError","BadRequest","Unauthorized","SubprotocolNotAcceptable","SubscriberAlreadyExists","TooManyInitialisationRequests","includes","subscribe","sink","done","errored","releaser","waitForReleaseOrThrowOnClose","next","finally","catch","dispose","terminate","wasClean","Object","defineProperty","value"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.graphqlWs = {}));\n})(this, (function (exports) { 'use strict';\n\n    /** @private */\n    function extendedTypeof(val) {\n        if (val === null) {\n            return 'null';\n        }\n        if (Array.isArray(val)) {\n            return 'array';\n        }\n        return typeof val;\n    }\n    /** @private */\n    function isObject(val) {\n        return extendedTypeof(val) === 'object';\n    }\n    /** @private */\n    function areGraphQLErrors(obj) {\n        return (Array.isArray(obj) &&\n            // must be at least one error\n            obj.length > 0 &&\n            // error has at least a message\n            obj.every((ob) => 'message' in ob));\n    }\n    /**\n     * Limits the WebSocket close event reason to not exceed a length of one frame.\n     * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n     *\n     * @private\n     */\n    function limitCloseReason(reason, whenTooLong) {\n        return reason.length < 124 ? reason : whenTooLong;\n    }\n\n    /**\n     *\n     * common\n     *\n     */\n    /**\n     * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n     *\n     * @category Common\n     */\n    const GRAPHQL_TRANSPORT_WS_PROTOCOL = 'graphql-transport-ws';\n    /**\n     * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n     *\n     * @private\n     */\n    const DEPRECATED_GRAPHQL_WS_PROTOCOL = 'graphql-ws';\n    /**\n     * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n     *\n     * @category Common\n     */\n    exports.CloseCode = void 0;\n    (function (CloseCode) {\n        CloseCode[CloseCode[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n        CloseCode[CloseCode[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n        CloseCode[CloseCode[\"BadRequest\"] = 4400] = \"BadRequest\";\n        CloseCode[CloseCode[\"BadResponse\"] = 4004] = \"BadResponse\";\n        /** Tried subscribing before connect ack */\n        CloseCode[CloseCode[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n        CloseCode[CloseCode[\"Forbidden\"] = 4403] = \"Forbidden\";\n        CloseCode[CloseCode[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n        CloseCode[CloseCode[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n        CloseCode[CloseCode[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n        /** Subscriber distinction is very important */\n        CloseCode[CloseCode[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n        CloseCode[CloseCode[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n    })(exports.CloseCode || (exports.CloseCode = {}));\n    /**\n     * Types of messages allowed to be sent by the client/server over the WS protocol.\n     *\n     * @category Common\n     */\n    exports.MessageType = void 0;\n    (function (MessageType) {\n        MessageType[\"ConnectionInit\"] = \"connection_init\";\n        MessageType[\"ConnectionAck\"] = \"connection_ack\";\n        MessageType[\"Ping\"] = \"ping\";\n        MessageType[\"Pong\"] = \"pong\";\n        MessageType[\"Subscribe\"] = \"subscribe\";\n        MessageType[\"Next\"] = \"next\";\n        MessageType[\"Error\"] = \"error\";\n        MessageType[\"Complete\"] = \"complete\";\n    })(exports.MessageType || (exports.MessageType = {}));\n    /**\n     * Validates the message against the GraphQL over WebSocket Protocol.\n     *\n     * Invalid messages will throw descriptive errors.\n     *\n     * @category Common\n     */\n    function validateMessage(val) {\n        if (!isObject(val)) {\n            throw new Error(`Message is expected to be an object, but got ${extendedTypeof(val)}`);\n        }\n        if (!val.type) {\n            throw new Error(`Message is missing the 'type' property`);\n        }\n        if (typeof val.type !== 'string') {\n            throw new Error(`Message is expects the 'type' property to be a string, but got ${extendedTypeof(val.type)}`);\n        }\n        switch (val.type) {\n            case exports.MessageType.ConnectionInit:\n            case exports.MessageType.ConnectionAck:\n            case exports.MessageType.Ping:\n            case exports.MessageType.Pong: {\n                if ('payload' in val && !isObject(val.payload)) {\n                    throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object or missing, but got \"${val.payload}\"`);\n                }\n                break;\n            }\n            case exports.MessageType.Subscribe: {\n                if (typeof val.id !== 'string') {\n                    throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n                }\n                if (!val.id) {\n                    throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n                }\n                if (!isObject(val.payload)) {\n                    throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${extendedTypeof(val.payload)}`);\n                }\n                if (typeof val.payload.query !== 'string') {\n                    throw new Error(`\"${val.type}\" message payload expects the 'query' property to be a string, but got ${extendedTypeof(val.payload.query)}`);\n                }\n                if (val.payload.variables != null && !isObject(val.payload.variables)) {\n                    throw new Error(`\"${val.type}\" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${extendedTypeof(val.payload.variables)}`);\n                }\n                if (val.payload.operationName != null &&\n                    extendedTypeof(val.payload.operationName) !== 'string') {\n                    throw new Error(`\"${val.type}\" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${extendedTypeof(val.payload.operationName)}`);\n                }\n                if (val.payload.extensions != null && !isObject(val.payload.extensions)) {\n                    throw new Error(`\"${val.type}\" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${extendedTypeof(val.payload.extensions)}`);\n                }\n                break;\n            }\n            case exports.MessageType.Next: {\n                if (typeof val.id !== 'string') {\n                    throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n                }\n                if (!val.id) {\n                    throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n                }\n                if (!isObject(val.payload)) {\n                    throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${extendedTypeof(val.payload)}`);\n                }\n                break;\n            }\n            case exports.MessageType.Error: {\n                if (typeof val.id !== 'string') {\n                    throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n                }\n                if (!val.id) {\n                    throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n                }\n                if (!areGraphQLErrors(val.payload)) {\n                    throw new Error(`\"${val.type}\" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(val.payload)}`);\n                }\n                break;\n            }\n            case exports.MessageType.Complete: {\n                if (typeof val.id !== 'string') {\n                    throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n                }\n                if (!val.id) {\n                    throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n                }\n                break;\n            }\n            default:\n                throw new Error(`Invalid message 'type' property \"${val.type}\"`);\n        }\n        return val;\n    }\n    /**\n     * Checks if the provided value is a valid GraphQL over WebSocket message.\n     *\n     * @deprecated Use `validateMessage` instead.\n     *\n     * @category Common\n     */\n    function isMessage(val) {\n        try {\n            validateMessage(val);\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    /**\n     * Parses the raw websocket message data to a valid message.\n     *\n     * @category Common\n     */\n    function parseMessage(data, reviver) {\n        try {\n            return validateMessage(data);\n        }\n        catch (_a) {\n            if (typeof data !== 'string') {\n                throw new Error('Only strings are parsable messages');\n            }\n            const message = JSON.parse(data, reviver);\n            return validateMessage(message);\n        }\n    }\n    /**\n     * Stringifies a valid message ready to be sent through the socket.\n     *\n     * @category Common\n     */\n    function stringifyMessage(msg, replacer) {\n        validateMessage(msg);\n        return JSON.stringify(msg, replacer);\n    }\n\n    /**\n     *\n     * client\n     *\n     */\n    /**\n     * Creates a disposable GraphQL over WebSocket client.\n     *\n     * @category Client\n     */\n    function createClient(options) {\n        const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout: lazyCloseTimeoutMs = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n            let retryDelay = 1000; // start with 1s delay\n            for (let i = 0; i < retries; i++) {\n                retryDelay *= 2;\n            }\n            await new Promise((resolve) => setTimeout(resolve, retryDelay +\n                // add random timeout from 300ms to 3s\n                Math.floor(Math.random() * (3000 - 300) + 300)));\n        }, shouldRetry = isLikeCloseEvent, isFatalConnectionProblem, on, webSocketImpl, \n        /**\n         * Generates a v4 UUID to be used as the ID using `Math`\n         * as the random number generator. Supply your own generator\n         * in case you need more uniqueness.\n         *\n         * Reference: https://gist.github.com/jed/982883\n         */\n        generateID = function generateUUID() {\n            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n                const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n                return v.toString(16);\n            });\n        }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver, } = options;\n        let ws;\n        if (webSocketImpl) {\n            if (!isWebSocket(webSocketImpl)) {\n                throw new Error('Invalid WebSocket implementation provided');\n            }\n            ws = webSocketImpl;\n        }\n        else if (typeof WebSocket !== 'undefined') {\n            ws = WebSocket;\n        }\n        else if (typeof global !== 'undefined') {\n            ws =\n                global.WebSocket ||\n                    // @ts-expect-error: Support more browsers\n                    global.MozWebSocket;\n        }\n        else if (typeof window !== 'undefined') {\n            ws =\n                window.WebSocket ||\n                    // @ts-expect-error: Support more browsers\n                    window.MozWebSocket;\n        }\n        if (!ws)\n            throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n        const WebSocketImpl = ws;\n        // websocket status emitter, subscriptions are handled differently\n        const emitter = (() => {\n            const message = (() => {\n                const listeners = {};\n                return {\n                    on(id, listener) {\n                        listeners[id] = listener;\n                        return () => {\n                            delete listeners[id];\n                        };\n                    },\n                    emit(message) {\n                        var _a;\n                        if ('id' in message)\n                            (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                    },\n                };\n            })();\n            const listeners = {\n                connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n                opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n                connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n                ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n                pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n                message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n                closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n                error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : [],\n            };\n            return {\n                onMessage: message.on,\n                on(event, listener) {\n                    const l = listeners[event];\n                    l.push(listener);\n                    return () => {\n                        l.splice(l.indexOf(listener), 1);\n                    };\n                },\n                emit(event, ...args) {\n                    // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                    for (const listener of [...listeners[event]]) {\n                        // @ts-expect-error: The args should fit\n                        listener(...args);\n                    }\n                },\n            };\n        })();\n        // invokes the callback either when an error or closed event is emitted,\n        // first one that gets called prevails, other emissions are ignored\n        function errorOrClosed(cb) {\n            const listening = [\n                // errors are fatal and more critical than close events, throw them first\n                emitter.on('error', (err) => {\n                    listening.forEach((unlisten) => unlisten());\n                    cb(err);\n                }),\n                // closes can be graceful and not fatal, throw them second (if error didnt throw)\n                emitter.on('closed', (event) => {\n                    listening.forEach((unlisten) => unlisten());\n                    cb(event);\n                }),\n            ];\n        }\n        let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n        async function connect() {\n            // clear the lazy close timeout immediatelly so that close gets debounced\n            // see: https://github.com/enisdenjo/graphql-ws/issues/388\n            clearTimeout(lazyCloseTimeout);\n            const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : (connecting = new Promise((connected, denied) => (async () => {\n                if (retrying) {\n                    await retryWait(retries);\n                    // subscriptions might complete while waiting for retry\n                    if (!locks) {\n                        connecting = undefined;\n                        return denied({ code: 1000, reason: 'All Subscriptions Gone' });\n                    }\n                    retries++;\n                }\n                emitter.emit('connecting');\n                const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n                let connectionAckTimeout, queuedPing;\n                function enqueuePing() {\n                    if (isFinite(keepAlive) && keepAlive > 0) {\n                        clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                        queuedPing = setTimeout(() => {\n                            if (socket.readyState === WebSocketImpl.OPEN) {\n                                socket.send(stringifyMessage({ type: exports.MessageType.Ping }));\n                                emitter.emit('ping', false, undefined);\n                            }\n                        }, keepAlive);\n                    }\n                }\n                errorOrClosed((errOrEvent) => {\n                    connecting = undefined;\n                    clearTimeout(connectionAckTimeout);\n                    clearTimeout(queuedPing);\n                    denied(errOrEvent);\n                    if (isLikeCloseEvent(errOrEvent) && errOrEvent.code === 4499) {\n                        socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n                        socket.onerror = null;\n                        socket.onclose = null;\n                    }\n                });\n                socket.onerror = (err) => emitter.emit('error', err);\n                socket.onclose = (event) => emitter.emit('closed', event);\n                socket.onopen = async () => {\n                    try {\n                        emitter.emit('opened', socket);\n                        const payload = typeof connectionParams === 'function'\n                            ? await connectionParams()\n                            : connectionParams;\n                        // connectionParams might take too long causing the server to kick off the client\n                        // the necessary error/close event is already reported - simply stop execution\n                        if (socket.readyState !== WebSocketImpl.OPEN)\n                            return;\n                        socket.send(stringifyMessage(payload\n                            ? {\n                                type: exports.MessageType.ConnectionInit,\n                                payload,\n                            }\n                            : {\n                                type: exports.MessageType.ConnectionInit,\n                                // payload is completely absent if not provided\n                            }, replacer));\n                        if (isFinite(connectionAckWaitTimeout) &&\n                            connectionAckWaitTimeout > 0) {\n                            connectionAckTimeout = setTimeout(() => {\n                                socket.close(exports.CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                            }, connectionAckWaitTimeout);\n                        }\n                        enqueuePing(); // enqueue ping (noop if disabled)\n                    }\n                    catch (err) {\n                        emitter.emit('error', err);\n                        socket.close(exports.CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n                    }\n                };\n                let acknowledged = false;\n                socket.onmessage = ({ data }) => {\n                    try {\n                        const message = parseMessage(data, reviver);\n                        emitter.emit('message', message);\n                        if (message.type === 'ping' || message.type === 'pong') {\n                            emitter.emit(message.type, true, message.payload); // received\n                            if (message.type === 'pong') {\n                                enqueuePing(); // enqueue next ping (noop if disabled)\n                            }\n                            else if (!disablePong) {\n                                // respond with pong on ping\n                                socket.send(stringifyMessage(message.payload\n                                    ? {\n                                        type: exports.MessageType.Pong,\n                                        payload: message.payload,\n                                    }\n                                    : {\n                                        type: exports.MessageType.Pong,\n                                        // payload is completely absent if not provided\n                                    }));\n                                emitter.emit('pong', false, message.payload);\n                            }\n                            return; // ping and pongs can be received whenever\n                        }\n                        if (acknowledged)\n                            return; // already connected and acknowledged\n                        if (message.type !== exports.MessageType.ConnectionAck)\n                            throw new Error(`First message cannot be of type ${message.type}`);\n                        clearTimeout(connectionAckTimeout);\n                        acknowledged = true;\n                        emitter.emit('connected', socket, message.payload); // connected = socket opened + acknowledged\n                        retrying = false; // future lazy connects are not retries\n                        retries = 0; // reset the retries on connect\n                        connected([\n                            socket,\n                            new Promise((_, reject) => errorOrClosed(reject)),\n                        ]);\n                    }\n                    catch (err) {\n                        socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                        emitter.emit('error', err);\n                        socket.close(exports.CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                    }\n                };\n            })())));\n            // if the provided socket is in a closing state, wait for the throw on close\n            if (socket.readyState === WebSocketImpl.CLOSING)\n                await throwOnClose;\n            let release = () => {\n                // releases this connection\n            };\n            const released = new Promise((resolve) => (release = resolve));\n            return [\n                socket,\n                release,\n                Promise.race([\n                    // wait for\n                    released.then(() => {\n                        if (!locks) {\n                            // and if no more locks are present, complete the connection\n                            const complete = () => socket.close(1000, 'Normal Closure');\n                            if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n                                // if the keepalive is set, allow for the specified calmdown time and\n                                // then complete if the socket is still open.\n                                lazyCloseTimeout = setTimeout(() => {\n                                    if (socket.readyState === WebSocketImpl.OPEN)\n                                        complete();\n                                }, lazyCloseTimeoutMs);\n                            }\n                            else {\n                                // otherwise complete immediately\n                                complete();\n                            }\n                        }\n                    }),\n                    // or\n                    throwOnClose,\n                ]),\n            ];\n        }\n        /**\n         * Checks the `connect` problem and evaluates if the client should retry.\n         */\n        function shouldRetryConnectOrThrow(errOrCloseEvent) {\n            // some close codes are worth reporting immediately\n            if (isLikeCloseEvent(errOrCloseEvent) &&\n                (isFatalInternalCloseCode(errOrCloseEvent.code) ||\n                    [\n                        exports.CloseCode.InternalServerError,\n                        exports.CloseCode.InternalClientError,\n                        exports.CloseCode.BadRequest,\n                        exports.CloseCode.BadResponse,\n                        exports.CloseCode.Unauthorized,\n                        // CloseCode.Forbidden, might grant access out after retry\n                        exports.CloseCode.SubprotocolNotAcceptable,\n                        // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n                        // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n                        exports.CloseCode.SubscriberAlreadyExists,\n                        exports.CloseCode.TooManyInitialisationRequests,\n                        // 4499, // Terminated, probably because the socket froze, we want to retry\n                    ].includes(errOrCloseEvent.code)))\n                throw errOrCloseEvent;\n            // client was disposed, no retries should proceed regardless\n            if (disposed)\n                return false;\n            // normal closure (possibly all subscriptions have completed)\n            // if no locks were acquired in the meantime, shouldnt try again\n            if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000)\n                return locks > 0;\n            // retries are not allowed or we tried to many times, report error\n            if (!retryAttempts || retries >= retryAttempts)\n                throw errOrCloseEvent;\n            // throw non-retryable connection problems\n            if (!shouldRetry(errOrCloseEvent))\n                throw errOrCloseEvent;\n            // @deprecated throw fatal connection problems immediately\n            if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent))\n                throw errOrCloseEvent;\n            // looks good, start retrying\n            return (retrying = true);\n        }\n        // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n        if (!lazy) {\n            (async () => {\n                locks++;\n                for (;;) {\n                    try {\n                        const [, , throwOnClose] = await connect();\n                        await throwOnClose; // will always throw because releaser is not used\n                    }\n                    catch (errOrCloseEvent) {\n                        try {\n                            if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                                return;\n                        }\n                        catch (errOrCloseEvent) {\n                            // report thrown error, no further retries\n                            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                        }\n                    }\n                }\n            })();\n        }\n        return {\n            on: emitter.on,\n            subscribe(payload, sink) {\n                const id = generateID();\n                let done = false, errored = false, releaser = () => {\n                    // for handling completions before connect\n                    locks--;\n                    done = true;\n                };\n                (async () => {\n                    locks++;\n                    for (;;) {\n                        try {\n                            const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                            // if done while waiting for connect, release the connection lock right away\n                            if (done)\n                                return release();\n                            const unlisten = emitter.onMessage(id, (message) => {\n                                switch (message.type) {\n                                    case exports.MessageType.Next: {\n                                        sink.next(message.payload);\n                                        return;\n                                    }\n                                    case exports.MessageType.Error: {\n                                        (errored = true), (done = true);\n                                        sink.error(message.payload);\n                                        releaser();\n                                        return;\n                                    }\n                                    case exports.MessageType.Complete: {\n                                        done = true;\n                                        releaser(); // release completes the sink\n                                        return;\n                                    }\n                                }\n                            });\n                            socket.send(stringifyMessage({\n                                id,\n                                type: exports.MessageType.Subscribe,\n                                payload,\n                            }, replacer));\n                            releaser = () => {\n                                if (!done && socket.readyState === WebSocketImpl.OPEN)\n                                    // if not completed already and socket is open, send complete message to server on release\n                                    socket.send(stringifyMessage({\n                                        id,\n                                        type: exports.MessageType.Complete,\n                                    }, replacer));\n                                locks--;\n                                done = true;\n                                release();\n                            };\n                            // either the releaser will be called, connection completed and\n                            // the promise resolved or the socket closed and the promise rejected.\n                            // whatever happens though, we want to stop listening for messages\n                            await waitForReleaseOrThrowOnClose.finally(unlisten);\n                            return; // completed, shouldnt try again\n                        }\n                        catch (errOrCloseEvent) {\n                            if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                                return;\n                        }\n                    }\n                })()\n                    .then(() => {\n                    // delivering either an error or a complete terminates the sequence\n                    if (!errored)\n                        sink.complete();\n                }) // resolves on release or normal closure\n                    .catch((err) => {\n                    sink.error(err);\n                }); // rejects on close events and errors\n                return () => {\n                    // dispose only of active subscriptions\n                    if (!done)\n                        releaser();\n                };\n            },\n            async dispose() {\n                disposed = true;\n                if (connecting) {\n                    // if there is a connection, close it\n                    const [socket] = await connecting;\n                    socket.close(1000, 'Normal Closure');\n                }\n            },\n            terminate() {\n                if (connecting) {\n                    // only if there is a connection\n                    emitter.emit('closed', {\n                        code: 4499,\n                        reason: 'Terminated',\n                        wasClean: false,\n                    });\n                }\n            },\n        };\n    }\n    function isLikeCloseEvent(val) {\n        return isObject(val) && 'code' in val && 'reason' in val;\n    }\n    function isFatalInternalCloseCode(code) {\n        if ([\n            1000,\n            1001,\n            1006,\n            1005,\n            1012,\n            1013,\n            1013, // Bad Gateway\n        ].includes(code))\n            return false;\n        // all other internal errors are fatal\n        return code >= 1000 && code <= 1999;\n    }\n    function isWebSocket(val) {\n        return (typeof val === 'function' &&\n            'constructor' in val &&\n            'CLOSED' in val &&\n            'CLOSING' in val &&\n            'CONNECTING' in val &&\n            'OPEN' in val);\n    }\n\n    exports.DEPRECATED_GRAPHQL_WS_PROTOCOL = DEPRECATED_GRAPHQL_WS_PROTOCOL;\n    exports.GRAPHQL_TRANSPORT_WS_PROTOCOL = GRAPHQL_TRANSPORT_WS_PROTOCOL;\n    exports.createClient = createClient;\n    exports.isMessage = isMessage;\n    exports.parseMessage = parseMessage;\n    exports.stringifyMessage = stringifyMessage;\n    exports.validateMessage = validateMessage;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"]},"metadata":{},"sourceType":"script"}